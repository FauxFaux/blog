title: Fosdem 2014
slug: fosdem-2014
date: 2014-02-03 21:35:23+00:00

I was at <a href="https://fosdem.org/2014/">Fosdem 2014</a>.  I experienced some things which may count as learning, or just exclamations.  I'm not really sure how this kind of thing works.  (editor's note: I guess, having written it, that the term is "braindump")

<ul>
	<li><a href="https://wiki.debian.org/ReproducibleBuilds">Reproducible Builds for Debian</a>: 65% of the archive can be reproduced from binaries we have available.  <code>readdir()</code> is a great source of entropy; timestamps are a great source of source-control noise.  Maybe we should make a <code>vcs-give-me-a-version</code> for people to use instead of <code>$(date)</code>.  We're heavily dependent upon old binaries, and on toolchains that will never be audited.  We trust debian developers to upload a binary that matches their source(??!).</li>
	<li><a href="http://rkennke.wordpress.com/2013/06/10/shenandoah-a-pauseless-gc-for-openjdk/">Shenandoah GC</a>: Non-gc threads can do useful gc work, by copying stuff off the dead bits of heap onto live bits during writes.  "Brooks pointers"(?) are a formalisation of that kind of store-and-forward kind of model in a atomic-compare-and-exchange world.  People build non-generational garbage collectors but apparently this is silly and always abandoned.  Concurrency without locking is hilarious.  8mb sub-heaps are cool.</li>
	<li><a href="http://www.sagemath.org/">Sage</a> is a nice bundle of <code>ipython --notebook</code> and loads of maths libraries, and a magic cloud thing, but demos are hard, and nearly any audience is going to respond better to <a href="http://nbviewer.ipython.org/github/jvns/talks/blob/master/pyconca2013/pistes-cyclables.ipynb">notebook</a> (yes that's really what it looks like when you're editing it) than the command-line.  Also, it was annoyingly broken on Android Chrome.</li>
	<li><a href="http://www.spark-2014.org/about">SPARK 2014</a>: Extending Ada to have the compiler check asserts; e.g. ensuring you never get bounds checks, cool and perfectly sensible; looked like they hadn't quite made it as automatic as I'd've hoped for Ada, which I chose to assume was a sensible language.  Additionally: Let's stop unit testing trivial stuff, and let the compiler show that it's correct.  Some great slides (which I can't find, yet) on how to layer your testing infrastructure when you have a competent compiler and devs who can tell it how to be happy.</li>
	<li>Scaling Dovecot: Nice overview of threads, clients, handoff, etc. in a world where you're expecting long-running IMAP connections (instead of the HTTP/REST nonsense I generally think about), and an overview of their load-balancing infrastructure which sounded pretty ... unique, rings of machines, rings of rings, ...</li>
	<li><a href="http://mageec.org/">Motivations for MAGEEC</a>: Why and how we should care about optimising for power; changing compiler optimisation cost models for power usage (instead of instruction length or expected speed).  Pretty heatmaps showing power usage across instructions, e.g. sometimes it uses less power (but is slower) to do operation on 32-bit units instead of 8-bit, etc.  Proposed a performance test framework (programming competition?!) targeting "total joules" instead of "code length" or "time".</li>
	<li>FOSDEM wifi: Defaulting to ipv6, and how to configure bind/etc. to make people able to access the ipv4 bits of the internet.  Massive shock seeing getting a reverse-dns response for an ipv6 address with a work hostname in.  Big (yeah, big) discussion with anyone who would listen about why DNSSEC and this didn't or couldn't be resolved, which was eventually laid to rest by <a href="http://blog.suriar.net/">Muz</a>.  <a href="https://code.google.com/p/android/issues/detail?id=32630" title="Android: Support connecting to IPv6-only wireless networks">Android does its wonderful wifi-reboot-loop if presented with wifi without ipv4 connectivity</a>.  <a href="https://github.com/keithw/mosh/issues/81">mosh doesn't support ipv6 yet</a>.</li>
	<li><a href="http://llvm.org/docs/Vectorizers.html">Autovectorisation in LLVM</a>: LLVM is flexible enough to deal with loads of people having a stab at things.  Cost models are hard, especially when they're across instruction boundaries and dependent on what the CPU is currently doing (none of the vectorisers do this right now).  It's hard to keep the right amount of information available when you're running much later in the compiler, although if it was in the original source then it's fine.  They're <strong>heavily</strong> dependent on inlining.  I wish Java was better at inlining.  It seems to fix everything.</li>
	<li><a href="http://s3.eurecom.fr/tools/avatar/">Avatar, running analysis tools on embedded stuff</a>:  Let's just pause for a moment here and look at this:
<img style="max-width: 100%" src="https://b.goeswhere.com/avatar_overview.png" alt="AVATAR block diagaram"/>
Wow.  It's some kind of black magic for running a huge binary blob that they don't have the code <em>nor the toolchain</em> for both on the real hardware and on an emulator and kind of syncing all of it backwards and forwards over python3 and multiple different connectors and multiple gdbs writing random memory editors into spare space in the embedded device and recompiling the qemu backend code with llvm (??!!) and running it through their symbolic execution framework and syncing that state all over and... basically I had no idea what was going on but <a href="https://lh3.ggpht.com/_D_Z-D2tzi14/TNeOOyIRPyI/AAAAAAAAEC8/o2knPYS4YSs/s1600/dogs21altalt.png">it was wonderous</a>.  No serious issues found in a Nokia 3310 yet, though.</li>
	<li><a href="http://llvm.linuxfoundation.org/">LLVM Linux</a>: The kernel and gcc have grown together, and hence the kernel gets away with all kinds of awful things that llvm just outright refuses to add support for.  The guy was amazingly angry about a tiny bit of C that gcc supports (badly), named VLAIS.  It's in some of the crypto code in the kernel <em>that gets copy-pasted between modules</em>.  This was far more horrifying to me.</li>
	<li>Power management: A system wide challenge: Hardware engineers are really smart and like to show it with maths and <a href="https://en.wikipedia.org/wiki/Clock_gating">clock gating</a>.  Understood some interesting things; e.g. it's worth shipping one high-nm/high-bin core (to run at a lower power and a lower frequency more of the time), and loads of low-nm/low-bin cores to run fast and loose.  Power usage is related to the frequency <em>cubed</em>.</li>
	<li><a href="http://valgrind.org/docs/manual/hg-manual.html">Helgrind for Valgrind</a>: Let's re-interpret concurrency as a graph.  It doesn't really matter what you were trying to do with your locks; just the presence of a lock or unlock implies that you meant to do something.  Add a graph edge to nearby other uses of that lock.  Other edges are time on the same thread.  Dominators.  Bam, done.  Then they optimised it with vector clocks, which I thought I'd escaped when it became acceptable to only understand <a href="http://thesecretlivesofdata.com/raft/">Raft</a>, not the other horror.</li>
	<li><a href="http://www.cl.cam.ac.uk/research/security/capsicum/">Capsicum</a>: Capabilities are a good way to do things.  Allows applications to drop arbitary privileges, i.e. "don't let me make any directories I've currently got open for reading writable, or let me do anything scary to the network card".  <code>tcpdump</code> as an example, which was nicely real-world.  Good slides comparing the other options on Linux and other OSes for sandboxing (e.g. Chromium).</li>
	<li>No more IPv4: A review of loads of stuff that would have been useful to know for the previously mentioned argument, that we had to learn from the horrors of wikipedia and nearby Cisco employees.</li>
	<li>Software Transactional Memory: Might help you write better code (declarative instead of imperative concurrency), and what looked like a declarative distributed transaction manager, which I completely failed to understand in any way.</li>
</ul>

9/10 would attend again.